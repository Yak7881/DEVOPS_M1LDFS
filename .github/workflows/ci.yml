name: CI — DevOps Rooms

# Ce pipeline se lance automatiquement sur chaque push et chaque pull request.
# Il vérifie que le repo est bien structuré et que le contenu est correct.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  check-structure:
    name: "Vérifier la structure du repo"
    runs-on: ubuntu-latest

    steps:
      # Étape 1 : Récupérer le code du repo
      - name: Checkout du code
        uses: actions/checkout@v4

      # Étape 2 : Vérifier que les fichiers obligatoires existent
      - name: Vérifier les fichiers obligatoires
        run: |
          echo "=== Vérification des fichiers obligatoires ==="
          MISSING=0

          # Liste des fichiers qui doivent exister
          FILES=(
            "README.md"
            "LICENSE"
            ".gitignore"
            "ROADMAP.md"
            "PROGRESS.md"
            "docs/START-HERE.md"
            "docs/rules-of-the-game.md"
            "docs/glossary.md"
            "docs/scoring.md"
            "docs/pipelines-cheatsheet.md"
            "docs/team-workflow-0-to-merge.md"
            "docs/roles-in-a-dev-team.md"
          )

          for f in "${FILES[@]}"; do
            if [ -f "$f" ]; then
              echo "$f"
            else
              echo "MANQUANT: $f"
              MISSING=$((MISSING + 1))
            fi
          done

          if [ $MISSING -gt 0 ]; then
            echo ""
            echo "$MISSING fichier(s) manquant(s) !"
            exit 1
          else
            echo ""
            echo "Tous les fichiers obligatoires sont présents."
          fi

      # Étape 3 : Vérifier que toutes les rooms existent
      - name: Vérifier les rooms
        run: |
          echo "=== Vérification des rooms ==="
          MISSING=0

          ROOMS=(
            "rooms/room-00-orientation"
            "rooms/room-01-version-control"
            "rooms/room-02-collaboration"
            "rooms/room-03-team-workflow"
            "rooms/room-04-github-gui"
            "rooms/room-05-pipelines"
            "rooms/room-06-testing"
            "rooms/room-07-release"
            "rooms/room-08-monitoring"
            "rooms/room-09-jenkins"
            "rooms/room-10-incident-response"
            "rooms/room-11-capstone"
          )

          for room in "${ROOMS[@]}"; do
            if [ -f "$room/README.md" ]; then
              echo "$room/README.md"
            else
              echo "MANQUANT: $room/README.md"
              MISSING=$((MISSING + 1))
            fi
          done

          if [ $MISSING -gt 0 ]; then
            echo ""
            echo "$MISSING room(s) sans README !"
            exit 1
          else
            echo ""
            echo "Toutes les rooms ont leur README."
          fi

      # Étape 4 : Vérifier le format markdown (pas de tabulations, fichiers non vides)
      - name: Vérifier le format des fichiers markdown
        run: |
          echo "=== Vérification du format markdown ==="
          ERRORS=0

          # Vérifier que les fichiers .md ne sont pas vides
          for f in $(find . -name "*.md" -not -path "./.git/*"); do
            if [ ! -s "$f" ]; then
              echo "VIDE: $f"
              ERRORS=$((ERRORS + 1))
            fi
          done

          # Vérifier le nombre total de fichiers markdown
          COUNT=$(find . -name "*.md" -not -path "./.git/*" | wc -l)
          echo "$COUNT fichiers markdown trouvés."

          if [ $ERRORS -gt 0 ]; then
            echo ""
            echo "$ERRORS fichier(s) markdown vide(s) !"
            exit 1
          else
            echo ""
            echo "Tous les fichiers markdown ont du contenu."
          fi

      # Étape 5 : Vérifier les liens internes markdown
      - name: Vérifier les liens internes
        run: |
          echo "=== Vérification des liens internes ==="
          BROKEN=0

          # Extraire les liens relatifs des fichiers markdown et vérifier qu'ils pointent vers des fichiers existants
          for mdfile in $(find . -name "*.md" -not -path "./.git/*"); do
            DIR=$(dirname "$mdfile")

            # Extraire les liens de type [texte](chemin) qui ne commencent pas par http
            LINKS=$(grep -oP '\[.*?\]\(\K[^)]+' "$mdfile" 2>/dev/null | grep -v '^http' | grep -v '^#' || true)

            for link in $LINKS; do
              # Retirer les ancres (#...)
              CLEAN=$(echo "$link" | sed 's/#.*//')
              if [ -n "$CLEAN" ]; then
                TARGET="$DIR/$CLEAN"
                if [ ! -e "$TARGET" ]; then
                  echo "Lien cassé dans $mdfile → $link"
                  BROKEN=$((BROKEN + 1))
                fi
              fi
            done
          done

          if [ $BROKEN -gt 0 ]; then
            echo ""
            echo "$BROKEN lien(s) potentiellement cassé(s)."
            echo "Vérifiez manuellement — certains peuvent être des ancres valides."
          else
            echo ""
            echo "Aucun lien cassé détecté."
          fi
